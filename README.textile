the database abstraction supports mysql mysqli PDO SQLiteDatabase AND SQLite3 now, and will support more in future...

h2. how to use it:

h3. database initialization: 

```php5
<?php
require_once 'Database.php';

// pdo
$db = Database::connect('pdo', 'mysql:dbname=test;host=localhost', 'root', 'root');
$db = Database::connect(array('pdo', 'mysql:dbname=test;host=localhost', 'root', 'root'));
$link = new PDO('mysql:host=localhost;dbname=test', 'root', 'root');
$db = Database::connect($link);

// mysql
$db = Database::connect('mysql', 'localhost', 'root', 'root', 'test');
$db = Database::connect(array('mysql', 'localhost', 'root', 'root', 'test'));
$link = mysql_connect('localhost', 'root', 'root');
mysql_select_db('test', $link);
$db = Database::connect($link);

// mysqli
$db = Database::connect('mysqli', 'localhost', 'root', 'root', 'test');
$db = Database::connect(array('mysqli', 'localhost', 'root', 'root', 'test'));
$link = new mysqli('localhost', 'root', 'root', 'test');
$db = Database::connect($link);
$link = mysqli_init();
$link->real_connect('localhost', 'root', 'root', 'test');
$db = Database::connect($link);

// sqlite
$db = Database::connect('sqlite', 'test.sqlite');
$db = Database::connect(array('sqlite', 'test.sqlite'));
$link = new SQLiteDatabase('test.sqlite');
$db = Database::connect($link);
$link = sqlite_open('test.sqlite');
$db = Database::connect($link);

// sqlite3
$db = Database::connect('sqlite3', 'test.sqlite3');
$db = Database::connect(array('sqlite3', 'test.sqlite3'));
$link = new SQLite3('test.sqlite3');
$db = Database::connect($link);
?>
```

h3.  use the $instance variable

```php5
<?php
require_once 'Database.php';

// set the Database::$instance
Database::$instance = Database::connect('mysql', 'localhost', 'root', 'root', 'test');

//in some function, u can use them like this:

print_r(test());

function test() {
    $sql = "SELECT * FROM test WHERE id = ?";
    $data = Database::$instance->getRow($sql, 1);

    return $data;
}
?>
```

h3. demo code: 

```php5
<?php
// origin sql
$sql = "SELECT * FROM test_table WHERE id = '$id' AND name = '$name'";
$result = $db->getAll($sql);

// if there are variables in sql, you can do it like this, and don't need to process the variables. : )
$sql = "SELECT * FROM test_table WHERE id = ? AND name = ?";
$result = $db->getAll($sql, $id, $name);

// you can allso use:
$sql = "SELECT * FROM test_table WHERE id = ? AND name = ?";
$result = $db->getAll($sql, array($id, $name));

// it allso support:
$sql = "SELECT * FROM test_table WHERE id = :id AND name = :name";
$result = $db->getAll($sql, array('name'=>$name, 'id'=>$id));
?>
```

h3. database methods:

```php5
<?php
public function getRow();
// get a row result
public function getCol();
// get a col result
public function getOne();
// get a column value
public function getAll();
// get all results
public function exec();
// execute a sql
public function lastInsertId();
// get the id of the last inserted row or sequence value
public function getDriver();
// get the origin link or object of the database driver
public function query();
// execute a sql and returns a statement object
public function fetch($query);
// fetch a result whith the statement object from query
?>
```

h3. i removed the code of initialization in class, the class just did the connecting work, you can exec 'the initialization sql' after connect like this, sure, it is lazy-executing just like the connecting.

```php5
<?php
//mysql
$db = Database::connect('mysql', 'localhost', 'root', 'root', 'test');
$db->initialization = array(
  'SET character_set_connection=utf8, character_set_results=utf8, character_set_client=binary',
  "SET sql_mode=''"
);
?>
```